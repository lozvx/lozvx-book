# 基础

 1. 接口和抽象类的区别是什么？

 Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：  
接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。  
类可以实现很多个接口，但是只能继承一个抽象类  
类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。  
抽象类可以在不提供接口方法实现的情况下实现接口。  
Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。  
Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。  
接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。  
也可以参考JDK8中抽象类和接口的区别



2. 什么是值传递和引用传递？

值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。一般认为,java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递



3. 进程和线程的区别是什么？

进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。

线程与进程的区别归纳：

a.地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。

b.通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。

c.调度和切换：线程上下文切换比进程上下文切换要快得多。

d.在多线程OS中，进程不是一个可执行的实体。





创建线程有几种不同的方式？你喜欢哪一种？为什么？  


有4种方式可以用来创建线程：  
继承Thread类  
实现Runnable接口  
应用程序可以使用Executor框架来创建线程池  
实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。还有一种方式是实现Callable接口



同步方法和同步代码块的区别是什么？  
区别：同步方法默认用this或者当前类class对象作为锁；同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用   synchronized（object）{代码内容}进行修饰；



在监视器\(Monitor\)内部，是如何做线程同步的？程序应该做哪种级别的同步？

[http://ifeve.com/monitors-java-synchronization-mechanism/](http://ifeve.com/monitors-java-synchronization-mechanism/)  
监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。



什么是死锁\(deadlock\)？

所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件：

* 互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
* 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放\)。
* 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
* 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。



如何确保N个线程可以访问N个资源同时又不导致死锁？

使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。  
  
  
快速失败\(fail-fast\)和安全失败\(fail-safe\)的区别是什么？  
一：快速失败（fail—fast）

          在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出Concurrent Modification Exception。

          原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果结构发生变化，就会改变modCount的值。每当迭代器使用hashNext\(\)/next\(\)遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。

      注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。

      场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。

    二：安全失败（fail—safe）

      采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。

      原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。

      缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。

          场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。  


HashMap和Hashtable有什么区别？  
 HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：  
HashMap允许键和值是null，而Hashtable键或者值都不允许是null。  
Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。  
HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举\(Enumeration\)。  
一般认为Hashtable是一个遗留的类。



Java集合类框架的最佳实践有哪些？  
 根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的数量是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。  
有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。  
为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。  
使用JDK提供的不变类\(immutable class\)作为Map的键可以避免为我们自己的类实现hashCode\(\)和equals\(\)方法。  
编程的时候接口优于实现。  
底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。



Java中垃圾回收有什么目的？什么时候进行垃圾回收？

垃圾回收是在内存中存在没有引用的对象或超过作用域的对象时进行。垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。



如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？  
不会，在下一个垃圾回收周期中，这个对象将是可被回收的。



JVM的永久代中会发生垃圾回收么？  
  
 垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收\(Full GC\)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区  
\(注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区\)  


什么是JDBC？  
JDBC是允许用户在不同数据库之间做选择的一个抽象层。JDBC允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。  
  
解释下驱动\(Driver\)在JDBC中的角色。  
JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。  




RMI体系结构分哪几层？  
  
 RMI体系结构分以下几层：  
存根和骨架层\(Stub and Skeleton layer\)：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的RMI服务。  
远程引用层\(Remote Reference Layer\)：RMI体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的。  
传输层\(Transport layer\)：这一层负责连接参与服务的两个JVM。这一层是建立在网络上机器间的TCP/IP连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略。



什么是Servlet？  
解释下Servlet的生命周期。



  
doGet\(\)方法和doPost\(\)方法有什么区别？  
doGet：GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。  
doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。  
  


HTTP响应的结构是怎么样的？  
 HTTP响应由三个部分组成：  
状态码\(Status Code\)：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码HttpServletResponse.SC\_OK。  
HTTP头部\(HTTP Header\)：它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。如何在Serlet中检索HTTP的头部看这里。  
主体\(Body\)：它包含了响应的内容。它可以包含HTML代码，图片，等等。主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成的



什么是cookie？session和cookie有什么区别？  
 cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。下面列出了session和cookie的区别：  
无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用cookie，但是，session仍然是能够工作的，因为客户端无法禁用服务端的session。  
在存储的数据量方面session和cookies也是不一样的。session能够存储任意的Java对象，cookie只能存储String类型的对象。



sendRedirect\(\)和forward\(\)方法有什么区别？

forward是服务器内部的跳转，浏览器的地址栏不会发生变化，同时可以把request和response传递给后一个请求。sendRedirect\(\)是浏览器方面的跳转，要发送两次请求，地址栏也会发生变化，同时request和response也会发生变化，重新生成新的对象。  
  
  


