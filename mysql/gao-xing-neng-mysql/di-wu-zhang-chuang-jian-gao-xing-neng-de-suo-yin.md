# 第五章 创建高性能的索引

MySQL支持的索引

B-Tree索引

InnoDB使用B+树结构存储索引，根据主键引用被索引的行。

例：

```text
create table people(
lastname varchar(50) not null,
firstname varchat(50) not null,
birthday date not null,
gender enum('m','f') not null,
key(lastname,firstname,birthday)
);
```

全值匹配： 指的是和索引中的所有列进行匹配。

匹配最左前缀：只使用索引的第一列或第一第二列

匹配列前缀：匹配某一列的值的开头部分

匹配范围值：查找姓在allen和bob之间的人

精确匹配某一列并范围匹配另外一列：

只访问索引的查询：查询只需要访问索引，而 无须访问数据行。



因为索引树的节点是有序的，所以索引还可以用于查询中的order by操作。

B-Tree索引的限制：

如果不是按照索引的最左列开始查找，则无法使用索引

不能跳过索引中的列，如只用lastname birthday查询

如果查询中有某个列的查询访问，则其右边的所有列都无法使用索引优化查找



### 使用索引扫描来排序：

MySQL有两种方式可以生成有序的结果：通过排序操作或者按照索引顺序扫描。

**如果EXPLAIN出来的type列的值为index，则说明MySQL使用了索引扫描来做排序**（区别于Extra列的Using Index）。

 只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样，MySQL才能够使用索引来对结果做排序。如果 查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表 时，才能使用索引做排序。ORDER BY子句和查询语句的限制是一样的，需要满足索引的最左前缀的要求，否则MySQL都需要执行排序操作，而无法利用索引排序。

特殊情况：ORDER BY 子句不满足索引最左前缀的要求，就是前导列为常量的时候。

![](../../.gitbook/assets/image%20%2823%29.png)

### 

### 索引和锁

索引可以让查询锁定更少的行。如果你的查询从不访问那些不需要的行，那么就会锁定更少的行，从两个方面来看这对性能有好处。

1 虽然InnoDB的行锁效率很高，内存使用也很少，但是锁定行的时候仍然会带来额外的开销。

2 锁定超过需要的行会增加锁竞争并减少并发性。



InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。

